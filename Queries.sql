-- 1) Test your database with more than 10 SQL queries. You are required to implement the following: 
-- • Design 1 or 2 queries for inserting, deleting, and updating the dataset. 
-- • Write at least 4 select queries. Ensure that your select queries utilize different types of statements, such as "join", "order by", "group by", subquery, etc.  
-- • Create procedures/functions for common operations such as inserting, updating, or deleting or selecting records. 

-- Insert, Update, and Delete Queries
-- 1. Insert Query:
INSERT INTO products (product_id, name, description, price, stock_quantity, category_id)
VALUES (1001, 'Smart Home Hub', 'Smart home hub with voice control', 149.99, 60, 5);

SELECT * FROM products;

-- 2. Update Query
UPDATE products
SET price=749.99, stock_quantity=90
WHERE product_id=1001;

SELECT * FROM products;

-- 3. Delete Query:
DELETE FROM products
WHERE product_id = 1001;

SELECT * FROM products;

-- Select Queries
-- 4. Join Query: Retrieve user orders with product details.
SELECT u.username, o.order_id, p.name AS product_name, oi.quantity, oi.price
FROM users u
JOIN orders o ON u.user_id = o.user_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id;

-- 5. Group By Query: Get total sales grouped by category.
SELECT c.category_name, SUM(oi.quantity * oi.price) AS total_sales
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
JOIN categories c ON p.category_id = c.category_id
GROUP BY c.category_name
ORDER BY total_sales DESC;

-- 6. Subquery: Find products that have never been reviewed.
SELECT name
FROM products
WHERE product_id NOT IN (SELECT DISTINCT product_id FROM reviews);

-- 7. Order By Query: Retrieve the top 5 most expensive products.
SELECT name, price
FROM products
ORDER BY price DESC
LIMIT 5;

-- Procedures/Functions
-- 8.Insert Product Procedure:
CREATE OR REPLACE FUNCTION insert_product(
  p_id INT,
  p_name VARCHAR,
  p_description TEXT,
  p_price NUMERIC,
  p_stock INT,
  p_category_id INT
) RETURNS VOID AS $$
BEGIN
  INSERT INTO products (product_id, name, description, price, stock_quantity, category_id)
  VALUES (p_id, p_name, p_description, p_price, p_stock, p_category_id);
END;
$$ LANGUAGE plpgsql;

SELECT insert_product(1001, 'Smart Home Hub', 'Smart home hub with voice control', 149.99, 60, 5);
SELECT * FROM products;

-- 9. Delete Product Procedure:
CREATE OR REPLACE FUNCTION delete_product(p_id INT) RETURNS VOID AS $$
BEGIN
  DELETE FROM products WHERE product_id = p_id;
END;
$$ LANGUAGE plpgsql;

SELECT delete_product(1001);
SELECT * FROM products;

-- 10. Function: Calculates the total revenue generated by a specific product
CREATE OR REPLACE FUNCTION get_product_revenue(product_id_input INT)
RETURNS NUMERIC(10, 2) AS $$
DECLARE
    total_revenue NUMERIC(10, 2);
BEGIN
    SELECT COALESCE(SUM(quantity * price), 0)
    INTO total_revenue
    FROM order_items
    WHERE product_id = product_id_input;

    RETURN total_revenue;
END;
$$ LANGUAGE plpgsql;

SELECT 
    p.product_id, 
    p.name AS product_name, 
    get_product_revenue(p.product_id) AS total_revenue
FROM products p
ORDER BY total_revenue DESC;


-- 11. Procedure: Transfer Stock Between Products
CREATE OR REPLACE PROCEDURE transfer_stock(
    sender_product_id INT,
    receiver_product_id INT,
    quantity_to_transfer INT
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- Deduct stock from the sender product
    UPDATE products
    SET stock_quantity = stock_quantity - quantity_to_transfer
    WHERE product_id = sender_product_id;

    -- Add stock to the receiver product
    UPDATE products
    SET stock_quantity = stock_quantity + quantity_to_transfer
    WHERE product_id = receiver_product_id;

    -- Raise a notice for confirmation
    RAISE NOTICE 'Successfully transferred % units from product ID % to product ID %', 
        quantity_to_transfer, sender_product_id, receiver_product_id;

    -- Commit transaction
    COMMIT;
END;
$$;

-- Calling Procedure
CALL transfer_stock(1, 2, 2);

SELECT product_id, name, stock_quantity 
FROM products 
WHERE product_id IN (1, 2);





-- 2) Transaction & Triggers:
CREATE OR REPLACE FUNCTION check_insufficient_stock()
RETURNS TRIGGER AS $$
BEGIN
    -- If the new stock quantity will be less than 0 after the update, raise an exception
    IF NEW.stock_quantity <= 0 THEN
        RAISE EXCEPTION 'Insufficient stock for Product ID %: Cannot go below zero stock.',
                         NEW.product_id;
    END IF;
    -- If the stock is sufficient, allow the transaction to proceed by returning NEW
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Creating a trigger 
CREATE TRIGGER prevent_insufficient_stock
BEFORE UPDATE OF stock_quantity ON products
FOR EACH ROW
WHEN (NEW.stock_quantity < 0)
EXECUTE FUNCTION check_insufficient_stock();

-- Let's say the current stock for product_id = 1 is 20.
UPDATE products
SET stock_quantity = stock_quantity - 30
WHERE product_id = 1;
-- This will fail because stock will become negative (i.e., -5).



-- 3) Indexing & Query Execution Analysis:
EXPLAIN ANALYZE
SELECT u.username, o.order_id, p.name AS product_name, oi.quantity, oi.price
FROM users u
JOIN orders o ON u.user_id = o.user_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id;


CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);
CREATE INDEX idx_products_product_id ON products(product_id);


EXPLAIN ANALYZE
SELECT c.category_name, SUM(oi.quantity * oi.price) AS total_sales
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
JOIN categories c ON p.category_id = c.category_id
GROUP BY c.category_name
ORDER BY total_sales DESC;


CREATE INDEX idx_order_items_product_id ON order_items(product_id);
CREATE INDEX idx_categories_category_id ON categories(category_id);
CREATE INDEX idx_order_items_quantity_price ON order_items(product_id, quantity, price);


EXPLAIN ANALYZE
SELECT name
FROM products
WHERE product_id NOT IN (SELECT DISTINCT product_id FROM reviews);


CREATE INDEX idx_reviews_product_id ON reviews(product_id);
